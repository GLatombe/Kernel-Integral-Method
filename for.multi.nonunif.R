for.multi.nonunif <- function(comm_data,site1,site2,trait_data,res,bandwith.fac = 1, samples.per.point = ceiling((10^(3+sqrt(ncol(comm_data))))/nrow(comm_data)), kde.bandwidth = estimate_bandwidth(trait_data), scales = kde.bandwidth * (sd.count), chunk.size=1000){
  
    first <- comm_data[site1, comm_data[site1,] > 0]
  second <- comm_data[site2, comm_data[site2,] > 0]
  trait1 <- trait_data[names(first),]
  trait2 <- trait_data[names(second),]

  ##compute point distributions using a modification of the hypervolume_gaussian() function from package hypervolume, to stop everything before resampling to uniform density
  if(length(chunk.size)==1){
    if(length(scales)==1){
      hypervolume1 = hypervolume_gaussian.custom(data=trait1,name='trait1',verbose = F,samples.per.point=samples.per.point,sd.count=3, scales=scales,chunk.size=chunk.size)
      hypervolume2 = hypervolume_gaussian.custom(data=trait2,name='trait2',verbose = F,samples.per.point=samples.per.point,sd.count=3, scales=scales,chunk.size=chunk.size)    
    }else{
    hypervolume1 = hypervolume_gaussian.custom(data=trait1,name='trait1',verbose = F,samples.per.point=samples.per.point,sd.count=3, scales=scales[[1]],chunk.size=chunk.size)
    hypervolume2 = hypervolume_gaussian.custom(data=trait2,name='trait2',verbose = F,samples.per.point=samples.per.point,sd.count=3, scales=scales[[2]],chunk.size=chunk.size)  
    }
  }else{
    if(length(scales)==1){
      hypervolume1 = hypervolume_gaussian.custom(data=trait1,name='trait1',verbose = F,samples.per.point=samples.per.point,sd.count=3, scales=scales,chunk.size=chunk.size[1,])
      hypervolume2 = hypervolume_gaussian.custom(data=trait2,name='trait2',verbose = F,samples.per.point=samples.per.point,sd.count=3, scales=scales,chunk.size=chunk.size[2,])
    }else{
    hypervolume1 = hypervolume_gaussian.custom(data=trait1,name='trait1',verbose = F,samples.per.point=samples.per.point,sd.count=3, scales=scales[[1]],chunk.size=chunk.size[1,])
    hypervolume2 = hypervolume_gaussian.custom(data=trait2,name='trait2',verbose = F,samples.per.point=samples.per.point,sd.count=3, scales=scales[[2]],chunk.size=chunk.size[2,])
    }
  }
  
  ##find the boundaries of the functional space containing all the points
  lims <- c(range(c(hypervolume1[[1]][,1],hypervolume2[[1]][,1])))
  for(i in 2:ncol(hypervolume1[[1]]))
    lims <- c(lims,range(c(hypervolume1[[1]][,i],hypervolume2[[1]][,i])))

  ##2dimensions - compute the KDEs from the random points generated by hypervolume_gaussian.custom()
  hvtest1.kkde.multi <- kde(x=hypervolume1[[1]],H=diag(estimate_bandwidth(trait_data)/bandwith.fac),xmin=lims[c(1,3)],xmax=lims[c(2,4)],gridsize=c((lims[2]-lims[1])/res,(lims[4]-lims[3])/res))
  hvtest2.kkde.multi <- kde(x=hypervolume2[[1]],H=diag(estimate_bandwidth(trait_data)/bandwith.fac),xmin=lims[c(1,3)],xmax=lims[c(2,4)],gridsize=c((lims[2]-lims[1])/res,(lims[4]-lims[3])/res))

  ##rescale the KDEs
  hvtest1.kkde.multi$estimate=hvtest1.kkde.multi$estimate/max(hvtest1.kkde.multi$estimate)
  hvtest2.kkde.multi$estimate=hvtest2.kkde.multi$estimate/max(hvtest2.kkde.multi$estimate)

  ##Compute the indices using the kernel integrals
  hv.bothT.multi <- array(c(hvtest1.kkde.multi$estimate,hvtest2.kkde.multi$estimate),c(dim(hvtest1.kkde.multi$estimate),2))
  hv.bothT.min.multi <- apply(hv.bothT.multi,1:length(dim(hvtest1.kkde.multi$estimate)),min)
  hv.bothT.max.multi <- apply(hv.bothT.multi,1:length(dim(hvtest1.kkde.multi$estimate)),max)
  Jac <- 1-(sum(hv.bothT.min.multi)/sum(hv.bothT.max.multi))
  Turn <- 2*(min(sum(hvtest1.kkde.multi$estimate),sum(hvtest2.kkde.multi$estimate))-sum(hv.bothT.min.multi))/sum(hv.bothT.max.multi)
  Nest <- Jac-Turn
  
  
  output <- list()
  output$indices <- c(Jac,Turn,Nest)
  output$kernel1 <- hvtest1.kkde.multi
  output$kernel2 <- hvtest2.kkde.multi
  output$points1 <- hypervolume1[[1]]
  output$points2 <- hypervolume2[[1]]
  
  return(output)
  
}