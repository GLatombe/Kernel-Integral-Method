for.multi.nonunif <- function(comm_data,site1,site2,trait_data,res,bandwith.fac = 1, samples.per.point = ceiling((10^(3+sqrt(ncol(comm_data))))/nrow(comm_data)), kde.bandwidth = estimate_bandwidth(trait_data), scales = kde.bandwidth * (sd.count), chunk.size=1000){
  
  
  tata <- creation_data(comm1 =data.frame(X = c(0,0,2.5,2.5), Y = c(1,7,1,7)) ,comm2 = data.frame(X = c(2,2,4,4), Y = c(0.5,3,0.5,3)),mode = "Uniform" ,points_number = npoints)
  comm_data = tata[[1]]
  site1 = "Site1"
  site2 = "Site2"
  trait_data = tata[[2]]
  res = 0.05
  scales = trait.var#1
  chunk.size = abundance
  samples.per.point = ceiling((10^(3+sqrt(ncol(comm_data))))/nrow(comm_data))
  
  
  
  first <- comm_data[site1, comm_data[site1,] > 0]
  second <- comm_data[site2, comm_data[site2,] > 0]
  trait1 <- trait_data[names(first),]
  trait2 <- trait_data[names(second),]

  ##compute point distributions using a modification of the hypervolume_gaussian() function from package hypervolume, to stop everything before resampling to uniform density
  hypervolume1 = hypervolume_gaussian.custom(data=trait1,name='trait1',verbose = F,samples.per.point=samples.per.point,sd.count=3, scales=scales[[1]],chunk.size=chunk.size[1,])
  hypervolume2 = hypervolume_gaussian.custom(data=trait2,name='trait2',verbose = F,samples.per.point=samples.per.point,sd.count=3, scales=scales[[2]],chunk.size=chunk.size[2,])

  ##find the boundaries of the functional space containing all the points
  lims <- c(range(c(hypervolume1[[2]][,1],hypervolume2[[2]][,1])))
  for(i in 2:ncol(hypervolume1[[2]]))
    lims <- c(lims,range(c(hypervolume1[[2]][,i],hypervolume2[[2]][,i])))

  ##2dimensions - compute the KDEs from the random points generated by hypervolume_gaussian.custom()
  hvtest1.kkde.multi <- kde(x=hypervolume1[[2]],H=diag(estimate_bandwidth(hypervolume1[[1]]@Data)/bandwith.fac),xmin=lims[c(1,3)],xmax=lims[c(2,4)],gridsize=c((lims[2]-lims[1])/res,(lims[4]-lims[3])/res))
  hvtest2.kkde.multi <- kde(x=hypervolume2[[2]],H=diag(estimate_bandwidth(hypervolume2[[1]]@Data)/bandwith.fac),xmin=lims[c(1,3)],xmax=lims[c(2,4)],gridsize=c((lims[2]-lims[1])/res,(lims[4]-lims[3])/res))

  ##rescale the KDEs
  hvtest1.kkde.multi$estimate=hvtest1.kkde.multi$estimate/max(hvtest1.kkde.multi$estimate)
  hvtest2.kkde.multi$estimate=hvtest2.kkde.multi$estimate/max(hvtest2.kkde.multi$estimate)

  ##Compute the indices using the kernel integrals
  hv.bothT.multi <- array(c(hvtest1.kkde.multi$estimate,hvtest2.kkde.multi$estimate),c(dim(hvtest1.kkde.multi$estimate),2))
  hv.bothT.min.multi <- apply(hv.bothT.multi,1:length(dim(hvtest1.kkde.multi$estimate)),min)
  hv.bothT.max.multi <- apply(hv.bothT.multi,1:length(dim(hvtest1.kkde.multi$estimate)),max)
  Jac <- 1-(sum(hv.bothT.min.multi)/sum(hv.bothT.max.multi))
  Turn <- 2*(min(sum(hvtest1.kkde.multi$estimate),sum(hvtest2.kkde.multi$estimate))-sum(hv.bothT.min.multi))/sum(hv.bothT.max.multi)
  Nest <- Jac-Turn
  
  
  output <- list()
  output$indices <- c(Jac,Turn,Nest)
  output$kernel1 <- hvtest1.kkde.multi
  output$kernel2 <- hvtest2.kkde.multi
  output$points1 <- hypervolume1[[2]]
  output$points2 <- hypervolume2[[2]]
  
  return(output)
  
}